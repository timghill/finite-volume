{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Finite volume methods for conservation laws This documentation describes the implementation of first-order finite volume methods on unstructured triangular meshes to solve the shallow water, heat, and nonlinear heat equations. General finite volume methods Before we solve specific examples, we should review finite volume methods. The methods here are written in a general way so that we can apply them to unstructured triangular meshes. The eventual form can be used for any shape of mesh, including regular structured meshes or unstructured mixed meshes. Consider a scalar conservation law for some quantity \\(u\\) of the form $$ \\frac{\\partial u}{\\partial t} + \\nabla \\cdot \\vec{q}(u, \\nabla u) = f$$ Now we integrate over a control area \\(\\Omega\\) (this could easily be extended to a volume in 3D space), $$ \\iint_\\Omega \\frac{\\partial u}{\\partial t} dA + \\iint_\\Omega\\nabla \\cdot \\vec{q}(u, \\nabla u)dA = \\iint_\\Omega f dA$$ Apply the divergence theorem to the second term, and pull the time derivative out of the first integral: $$ \\frac{\\partial}{\\partial t} \\iint_\\Omega u dA + \\int_{\\partial\\Omega}\\vec{q}(u, \\nabla u)\\cdot\\vec{n}dl = \\iint_\\Omega f dA$$ Now, let \\(\\bar{u}\\) be the average value of \\(u\\) over \\(\\Omega\\), \\(F\\) be the average of \\(f\\), and \\(|\\Omega|\\) be the area. Then we have $$ |\\Omega|\\frac{\\partial \\bar{u}}{\\partial t} + \\int_{\\partial\\Omega}\\vec{q}(u, \\nabla u)\\cdot\\vec{n}dl = |\\Omega| F$$ This yields an important equation for the average value of \\(u\\), $$ \\frac{\\partial \\bar{u}}{\\partial t} + \\frac{1}{|\\Omega|}\\int_{\\partial\\Omega}\\vec{q}(u, \\nabla u)\\cdot\\vec{n}dl = F$$ This equation says that the average value of \\(u\\) only changes due to the net flux flowing out through the boundary (first term) or the source term \\(F\\). This result should not be surprising or new, but it is an important step along the way to the semi-discrete form. To discretize in space, suppose that \\(\\Omega\\) is a polygon with \\(N\\) edges (extend to 3D by considering a polyhedron with \\(N\\) faces). Then we can break up the contour integral to be the sum of contributions from each edge. On each edge, we replace the line integral by the average value \\(\\vec{q}_k\\) multiplied by the edge length \\(l_k\\). Therefore, we have $$ \\frac{\\partial \\bar{u}}{\\partial t} + \\frac{1}{|\\Omega|} \\sum_{k=1}^N \\vec{q}_k \\cdot \\vec{n}_k l_k = F$$ This is called the semi-discrete form, since the spatial component has been discretized but the temporal component has not. Note that the method is not yet complete since we have not specified how to calculate the edge values \\(\\vec{q}_k\\).","title":"Home"},{"location":"#finite-volume-methods-for-conservation-laws","text":"This documentation describes the implementation of first-order finite volume methods on unstructured triangular meshes to solve the shallow water, heat, and nonlinear heat equations.","title":"Finite volume methods for conservation laws"},{"location":"#general-finite-volume-methods","text":"Before we solve specific examples, we should review finite volume methods. The methods here are written in a general way so that we can apply them to unstructured triangular meshes. The eventual form can be used for any shape of mesh, including regular structured meshes or unstructured mixed meshes. Consider a scalar conservation law for some quantity \\(u\\) of the form $$ \\frac{\\partial u}{\\partial t} + \\nabla \\cdot \\vec{q}(u, \\nabla u) = f$$ Now we integrate over a control area \\(\\Omega\\) (this could easily be extended to a volume in 3D space), $$ \\iint_\\Omega \\frac{\\partial u}{\\partial t} dA + \\iint_\\Omega\\nabla \\cdot \\vec{q}(u, \\nabla u)dA = \\iint_\\Omega f dA$$ Apply the divergence theorem to the second term, and pull the time derivative out of the first integral: $$ \\frac{\\partial}{\\partial t} \\iint_\\Omega u dA + \\int_{\\partial\\Omega}\\vec{q}(u, \\nabla u)\\cdot\\vec{n}dl = \\iint_\\Omega f dA$$ Now, let \\(\\bar{u}\\) be the average value of \\(u\\) over \\(\\Omega\\), \\(F\\) be the average of \\(f\\), and \\(|\\Omega|\\) be the area. Then we have $$ |\\Omega|\\frac{\\partial \\bar{u}}{\\partial t} + \\int_{\\partial\\Omega}\\vec{q}(u, \\nabla u)\\cdot\\vec{n}dl = |\\Omega| F$$ This yields an important equation for the average value of \\(u\\), $$ \\frac{\\partial \\bar{u}}{\\partial t} + \\frac{1}{|\\Omega|}\\int_{\\partial\\Omega}\\vec{q}(u, \\nabla u)\\cdot\\vec{n}dl = F$$ This equation says that the average value of \\(u\\) only changes due to the net flux flowing out through the boundary (first term) or the source term \\(F\\). This result should not be surprising or new, but it is an important step along the way to the semi-discrete form. To discretize in space, suppose that \\(\\Omega\\) is a polygon with \\(N\\) edges (extend to 3D by considering a polyhedron with \\(N\\) faces). Then we can break up the contour integral to be the sum of contributions from each edge. On each edge, we replace the line integral by the average value \\(\\vec{q}_k\\) multiplied by the edge length \\(l_k\\). Therefore, we have $$ \\frac{\\partial \\bar{u}}{\\partial t} + \\frac{1}{|\\Omega|} \\sum_{k=1}^N \\vec{q}_k \\cdot \\vec{n}_k l_k = F$$ This is called the semi-discrete form, since the spatial component has been discretized but the temporal component has not. Note that the method is not yet complete since we have not specified how to calculate the edge values \\(\\vec{q}_k\\).","title":"General finite volume methods"},{"location":"heat_equation/","text":"Heat equation The heat equation is usually written $$\\frac{\\partial u}{\\partial t} = \\gamma \\nabla^2 u,$$ but it can also be written as a conservation law, $$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot \\vec{q} = f$$, with $$\\vec{q} = -\\gamma\\nabla u$$. Therefore, we get the same semi-discrete form, $$ \\frac{\\partial \\bar{u}}{\\partial t} + \\frac{1}{|\\Omega|} \\sum_{k=1}^N \\vec{q}_k \\cdot \\vec{n}_k l_k = F.$$ The primary difficulty in solving the heat equation is that the flux depends directly on the gradient of \\(u\\). The numerical flux function we use is simply the exact flux, $$q_k = -\\gamma \\nabla u\\big\\rvert_{\\Gamma_k}.$$ The difficulty lies in calculating $\\nabla u$. We have a few different approaches of varying complexity. Green-Gauss method The Green-Gauss method uses the Green-Gauss/divergence theorem to calculate the gradient. We follow the same approach as we did to derive the general finite volume semi-discrete form, and find $$\\nabla u = \\frac{1}{|\\Omega|} \\sum_{k=1}^N u_k \\vec{n}_k$$, where the edge value \\(\\vec{u}_k\\) is calculated as the average of the neighbouring elements, $$\\vec{u}_k = \\frac{1}{2}(\\vec{u}_1 + \\vec{u}_2)$$ This method is simple to implement, but it has been shown to be inconsistent on unstructured meshes. That is, the gradient calculation converges to an incorrect value as the mesh is refined. The code below calculates the gradient using the green-gauss method: vx = zeros ( size ( v )); % x-component of gradient of v, defined on elements vy = zeros ( size ( v )); % y-component of gradient of v, defined on elements % First compute the gradient of v by integrating over triangle edges (e.g. % by applying divergence theorem) for ii = 1 : dmesh . tri . n_elements for kk=1:3 nvec =[ dmesh . tri . nx ( ii , kk ), dmesh . tri . ny ( ii , kk )]; r = dmesh . tri . ds ( ii , kk ) / dmesh . tri . area ( ii ); iEdge = dmesh . tri . connect_el_edge ( ii , kk ); v1 = v ( ii ); adj_i = dmesh . tri . connect_el_el ( ii , kk ); if adj_i>0 v2 = v ( adj_i ); else % Apply boundary conditions if strcmp(params.bc,'dirichlet') v2 = params . v_dirichlet ; elseif strcmp(params.bc,'neumann') v2 = v1 ; elseif strcmp(params.bc,'flux') v2 = v1 ; end end v_bndry = 0.5 * ( v1 + v2 ); vx ( ii ) = vx ( ii ) + r * v_bndry * nvec ( 1 ); vy ( ii ) = vy ( ii ) + r * v_bndry * nvec ( 2 ); end end Green-Gauss hybrid method We can fix the issues with the Green-Gauss method by being smarter in calculating the edge value \\(u_k\\). Let \\({\\Gamma_i}\\}_{i=1}^m\\) be the set of elements that share a node with edge \\(\\Gamma_k\\). Then, for an arbitrary element, we can expand $$u_i = u_k + \\frac{\\partial u_k}{\\partial x}\\Delta x + \\frac{\\partial u_k}{\\partial y}\\Delta y.$$ Combining the \\(m\\) equations, we find a matrix system $$\\begin{bmatrix} 1 && \\Delta x_1 && \\Delta y_1 \\\\ 1 && \\Delta x_2 && \\Delta y_2 \\\\ && \\vdots && \\\\ 1 && \\Delta x_m && \\Delta y_m \\end{bmatrix} \\begin{bmatrix} u_k \\\\ \\frac{\\partial u_k}{\\partial x} \\\\ \\frac{\\partial u_k}{\\partial y} \\end{bmatrix} = \\begin{bmatrix} u_1 \\\\ u_2 \\\\ \\vdots \\\\ u_m \\end{bmatrix}$$ We write this as $$ A\\vec{x} = \\vec{b}$$. The last step is to assign weights to each of these equations. For each element we define a weight \\(w_k = (\\Delta x_k^2 + \\Delta y_k^2)^{-1/2}\\), which definethe diagonal weight matrix \\(W\\), with \\((W_kk) = w_k \\). Therefore, we solve the system $$ W A \\vec{x} = W \\vec{b}$$ for \\(\\vec{x}\\) in the least-squares sense. The code below calculates the gradient using the green-gauss hybrid method: vx = zeros ( size ( v )); % x-component of gradient of v, defined on elements vy = zeros ( size ( v )); % y-component of gradient of v, defined on elements % First compute the gradient of v by integrating over triangle edges (e.g. % by applying divergence theorem) for ii = 1 : dmesh . tri . n_elements for kk=1:3 nvec =[ dmesh . tri . nx ( ii , kk ), dmesh . tri . ny ( ii , kk )]; r = dmesh . tri . ds ( ii , kk ) / dmesh . tri . area ( ii ); iEdge = dmesh . tri . connect_el_edge ( ii , kk ); neigh_els = dmesh . tri . edge_stencil { iEdge }; edgex = dmesh . tri . edge_midpoints ( iEdge , 1 ); edgey = dmesh . tri . edge_midpoints ( iEdge , 2 ); dx = dmesh . tri . elements ( neigh_els , 1 ) - edgex ; dy = dmesh . tri . elements ( neigh_els , 2 ) - edgey ; A = [ ones ( size ( dx )), dx , dy ]; b = v ( neigh_els ); W = diag ( 1. / sqrt ( dx .^ 2 + dy .^ 2 )); W = W / sum ( W (:)); x_lsq = ( W * A ) \\ ( W * b ); v_bndry = x_lsq ( 1 ); vx ( ii ) = vx ( ii ) + r * v_bndry * nvec ( 1 ); vy ( ii ) = vy ( ii ) + r * v_bndry * nvec ( 2 ); end end Least squares method Instead of applying the divergence theorem, we can construct a least squares problem directly for the gradient. Consider an arbitrary element \\(\\Omega_i\\), and let \\({\\Omega_k}_1^m\\) represent the elements that share a node with this element. Then, for each element we write $$u_k = u_i + \\frac{\\partial u_i}{\\partial x}\\Delta x_i + \\frac{\\partial u_i}{\\partial y}\\Delta y_i$$ Assembling these \\(m\\) equations into a matrix system, we have $$\\begin{bmatrix} \\Delta x_1 & \\Delta y_1 \\\\ \\Delta x_2 & \\Delta y_2 \\\\ \\vdots & \\\\ \\Delta x_m & \\Delta y_m \\end{bmatrix} \\begin{bmatrix} u_{x,i} \\\\ u_{y,i} \\end{bmatrix} = \\begin{bmatrix} u_1 - u_i \\\\ u_2 - u_i \\\\ \\vdots u_m - u_i \\end{bmatrix}$$ We solve this equation using the same weighted approach as the Green-Gauss least squares method. The following code calculates the gradient: for ii = 1 : dmesh . tri . n_elements neigh_els = dmesh . tri . node_stencil_extended { ii }; elx = dmesh . tri . elements ( ii , 1 ); ely = dmesh . tri . elements ( ii , 2 ); neighx = dmesh . tri . elements ( neigh_els , 1 ); neighy = dmesh . tri . elements ( neigh_els , 2 ); dx = neighx - elx ; dy = neighy - ely ; A = [ dx , dy ]; b = v ( neigh_els ) - v ( ii ); W = diag ( 1. / sqrt ( dx .^ 2 + dy .^ 2 )); W = W / sum ( W (:)); x_lsq = ( W * A ) \\ ( W * b ); vx ( ii ) = x_lsq ( 1 ); vy ( ii ) = x_lsq ( 2 ); end Nonlinear heat equation We can also consider a more general flux of the form $$ \\vec{q} = -\\gamma u^\\alpha \\left| \\nabla u \\right|^{\\beta - 1} \\nabla u.$$ This allows us to simulate the heat equation (\\(\\alpha = 0, \\beta = 1)\\), a nonlinear heat equation \\((\\alpha = \\beta = 1)\\), or a turbulent flow parameterization \\(\\alpha = 3/2, \\beta = 1/2\\).","title":"Heat equation"},{"location":"heat_equation/#heat-equation","text":"The heat equation is usually written $$\\frac{\\partial u}{\\partial t} = \\gamma \\nabla^2 u,$$ but it can also be written as a conservation law, $$\\frac{\\partial u}{\\partial t} + \\nabla \\cdot \\vec{q} = f$$, with $$\\vec{q} = -\\gamma\\nabla u$$. Therefore, we get the same semi-discrete form, $$ \\frac{\\partial \\bar{u}}{\\partial t} + \\frac{1}{|\\Omega|} \\sum_{k=1}^N \\vec{q}_k \\cdot \\vec{n}_k l_k = F.$$ The primary difficulty in solving the heat equation is that the flux depends directly on the gradient of \\(u\\). The numerical flux function we use is simply the exact flux, $$q_k = -\\gamma \\nabla u\\big\\rvert_{\\Gamma_k}.$$ The difficulty lies in calculating $\\nabla u$. We have a few different approaches of varying complexity.","title":"Heat equation"},{"location":"heat_equation/#green-gauss-method","text":"The Green-Gauss method uses the Green-Gauss/divergence theorem to calculate the gradient. We follow the same approach as we did to derive the general finite volume semi-discrete form, and find $$\\nabla u = \\frac{1}{|\\Omega|} \\sum_{k=1}^N u_k \\vec{n}_k$$, where the edge value \\(\\vec{u}_k\\) is calculated as the average of the neighbouring elements, $$\\vec{u}_k = \\frac{1}{2}(\\vec{u}_1 + \\vec{u}_2)$$ This method is simple to implement, but it has been shown to be inconsistent on unstructured meshes. That is, the gradient calculation converges to an incorrect value as the mesh is refined. The code below calculates the gradient using the green-gauss method: vx = zeros ( size ( v )); % x-component of gradient of v, defined on elements vy = zeros ( size ( v )); % y-component of gradient of v, defined on elements % First compute the gradient of v by integrating over triangle edges (e.g. % by applying divergence theorem) for ii = 1 : dmesh . tri . n_elements for kk=1:3 nvec =[ dmesh . tri . nx ( ii , kk ), dmesh . tri . ny ( ii , kk )]; r = dmesh . tri . ds ( ii , kk ) / dmesh . tri . area ( ii ); iEdge = dmesh . tri . connect_el_edge ( ii , kk ); v1 = v ( ii ); adj_i = dmesh . tri . connect_el_el ( ii , kk ); if adj_i>0 v2 = v ( adj_i ); else % Apply boundary conditions if strcmp(params.bc,'dirichlet') v2 = params . v_dirichlet ; elseif strcmp(params.bc,'neumann') v2 = v1 ; elseif strcmp(params.bc,'flux') v2 = v1 ; end end v_bndry = 0.5 * ( v1 + v2 ); vx ( ii ) = vx ( ii ) + r * v_bndry * nvec ( 1 ); vy ( ii ) = vy ( ii ) + r * v_bndry * nvec ( 2 ); end end","title":"Green-Gauss method"},{"location":"heat_equation/#green-gauss-hybrid-method","text":"We can fix the issues with the Green-Gauss method by being smarter in calculating the edge value \\(u_k\\). Let \\({\\Gamma_i}\\}_{i=1}^m\\) be the set of elements that share a node with edge \\(\\Gamma_k\\). Then, for an arbitrary element, we can expand $$u_i = u_k + \\frac{\\partial u_k}{\\partial x}\\Delta x + \\frac{\\partial u_k}{\\partial y}\\Delta y.$$ Combining the \\(m\\) equations, we find a matrix system $$\\begin{bmatrix} 1 && \\Delta x_1 && \\Delta y_1 \\\\ 1 && \\Delta x_2 && \\Delta y_2 \\\\ && \\vdots && \\\\ 1 && \\Delta x_m && \\Delta y_m \\end{bmatrix} \\begin{bmatrix} u_k \\\\ \\frac{\\partial u_k}{\\partial x} \\\\ \\frac{\\partial u_k}{\\partial y} \\end{bmatrix} = \\begin{bmatrix} u_1 \\\\ u_2 \\\\ \\vdots \\\\ u_m \\end{bmatrix}$$ We write this as $$ A\\vec{x} = \\vec{b}$$. The last step is to assign weights to each of these equations. For each element we define a weight \\(w_k = (\\Delta x_k^2 + \\Delta y_k^2)^{-1/2}\\), which definethe diagonal weight matrix \\(W\\), with \\((W_kk) = w_k \\). Therefore, we solve the system $$ W A \\vec{x} = W \\vec{b}$$ for \\(\\vec{x}\\) in the least-squares sense. The code below calculates the gradient using the green-gauss hybrid method: vx = zeros ( size ( v )); % x-component of gradient of v, defined on elements vy = zeros ( size ( v )); % y-component of gradient of v, defined on elements % First compute the gradient of v by integrating over triangle edges (e.g. % by applying divergence theorem) for ii = 1 : dmesh . tri . n_elements for kk=1:3 nvec =[ dmesh . tri . nx ( ii , kk ), dmesh . tri . ny ( ii , kk )]; r = dmesh . tri . ds ( ii , kk ) / dmesh . tri . area ( ii ); iEdge = dmesh . tri . connect_el_edge ( ii , kk ); neigh_els = dmesh . tri . edge_stencil { iEdge }; edgex = dmesh . tri . edge_midpoints ( iEdge , 1 ); edgey = dmesh . tri . edge_midpoints ( iEdge , 2 ); dx = dmesh . tri . elements ( neigh_els , 1 ) - edgex ; dy = dmesh . tri . elements ( neigh_els , 2 ) - edgey ; A = [ ones ( size ( dx )), dx , dy ]; b = v ( neigh_els ); W = diag ( 1. / sqrt ( dx .^ 2 + dy .^ 2 )); W = W / sum ( W (:)); x_lsq = ( W * A ) \\ ( W * b ); v_bndry = x_lsq ( 1 ); vx ( ii ) = vx ( ii ) + r * v_bndry * nvec ( 1 ); vy ( ii ) = vy ( ii ) + r * v_bndry * nvec ( 2 ); end end","title":"Green-Gauss hybrid method"},{"location":"heat_equation/#least-squares-method","text":"Instead of applying the divergence theorem, we can construct a least squares problem directly for the gradient. Consider an arbitrary element \\(\\Omega_i\\), and let \\({\\Omega_k}_1^m\\) represent the elements that share a node with this element. Then, for each element we write $$u_k = u_i + \\frac{\\partial u_i}{\\partial x}\\Delta x_i + \\frac{\\partial u_i}{\\partial y}\\Delta y_i$$ Assembling these \\(m\\) equations into a matrix system, we have $$\\begin{bmatrix} \\Delta x_1 & \\Delta y_1 \\\\ \\Delta x_2 & \\Delta y_2 \\\\ \\vdots & \\\\ \\Delta x_m & \\Delta y_m \\end{bmatrix} \\begin{bmatrix} u_{x,i} \\\\ u_{y,i} \\end{bmatrix} = \\begin{bmatrix} u_1 - u_i \\\\ u_2 - u_i \\\\ \\vdots u_m - u_i \\end{bmatrix}$$ We solve this equation using the same weighted approach as the Green-Gauss least squares method. The following code calculates the gradient: for ii = 1 : dmesh . tri . n_elements neigh_els = dmesh . tri . node_stencil_extended { ii }; elx = dmesh . tri . elements ( ii , 1 ); ely = dmesh . tri . elements ( ii , 2 ); neighx = dmesh . tri . elements ( neigh_els , 1 ); neighy = dmesh . tri . elements ( neigh_els , 2 ); dx = neighx - elx ; dy = neighy - ely ; A = [ dx , dy ]; b = v ( neigh_els ) - v ( ii ); W = diag ( 1. / sqrt ( dx .^ 2 + dy .^ 2 )); W = W / sum ( W (:)); x_lsq = ( W * A ) \\ ( W * b ); vx ( ii ) = x_lsq ( 1 ); vy ( ii ) = x_lsq ( 2 ); end","title":"Least squares method"},{"location":"heat_equation/#nonlinear-heat-equation","text":"We can also consider a more general flux of the form $$ \\vec{q} = -\\gamma u^\\alpha \\left| \\nabla u \\right|^{\\beta - 1} \\nabla u.$$ This allows us to simulate the heat equation (\\(\\alpha = 0, \\beta = 1)\\), a nonlinear heat equation \\((\\alpha = \\beta = 1)\\), or a turbulent flow parameterization \\(\\alpha = 3/2, \\beta = 1/2\\).","title":"Nonlinear heat equation"},{"location":"shallow_water/","text":"Shallow water equations Our finite volume methods were originally developed for the shallow water equations. In a few senses this was an odd choice: Our eventual model has a scalar state variable. Our model is diffusive, so we do not need to add numerical diffusion. Nevertheless, they are a good test for our methods and provide a good case study. Two-dimensional shallow water equations The shallow water solver solves the two-dimensional system of equations $$\\frac{\\partial}{\\partial t} \\begin{bmatrix} h \\\\ hu \\\\ hv \\end{bmatrix} + \\frac{\\partial}{\\partial x} \\begin{bmatrix} hu \\\\ hu^2 + \\frac{1}{2}gh^2 \\\\ huv \\end{bmatrix} + \\frac{\\partial}{\\partial y} \\begin{bmatrix} hv \\\\ huv \\\\ hv^2 + \\frac{1}{2}gh^2 \\end{bmatrix} = 0$$ We note that the conserved quantities in these equations are not the physical variables \\((h, u, v)\\), but are the depth and momenta \\(\\vec{u} = (h, m_x, m_y)\\), where \\(m-x = hu\\) and \\(m_y = hv\\). In terms of these conserved quantities, the equations become $$\\frac{\\partial}{\\partial t} \\begin{bmatrix} h \\\\ m_x \\\\ m_y \\end{bmatrix} + \\frac{\\partial}{\\partial x} \\begin{bmatrix} m_x \\\\ \\frac{m_x^2}{h} + \\frac{1}{2}gh^2 \\\\ \\frac{m_x m_y}{h} \\end{bmatrix} + \\frac{\\partial}{\\partial y} \\begin{bmatrix} m_y \\\\ \\frac{m_x m_y}{h} \\\\ \\frac{m_y^2}{h} + \\frac{1}{2}gh^2 \\end{bmatrix} = 0$$ We also note the symmetry between \\(x\\) and \\(y\\). We recognize the \\(\\frac{\\partial}{\\partial x}\\) term as representing the flux in the \\(x\\)-direction, and the \\(\\frac{\\partial}{\\partial y}\\) term as representing the flux in the \\(y\\)-direction (for example by integrating over a square). To apply finite volume methods, we therefore need to write the flux generally for normal and tangent momentum components. Let \\(m_n\\) by the normal component of momentum, and \\(m_\\tau\\) be the tangent component with respect to a a cell boundary. Then, we have that the flux is $$ \\vec{f}(\\vec{u}) = \\begin{bmatrix} f_h \\\\ f_n \\\\ f_\\tau \\end{bmatrix} = \\begin{bmatrix} m_n \\\\ \\frac{m_x^n}{h} + \\frac{1}{2}gh^2 \\\\ \\frac{m_n m_\\tau}{h} \\end{bmatrix}$$ Note that the first component says that convergence of the normal component of momentum causes an increase in water depth. This is exactly what we want! Now, we can write the system of equations as $$\\frac{\\partial \\vec{u}}{\\partial t} + \\frac{\\partial}{\\partial n} \\vec{f}(\\vec{u}) + \\frac{\\partial}{\\partial \\tau} \\vec{f}(\\vec{u}) = 0$$ where $\\vec{n} and \\vec{\\tau}$ are the normal and tangent vectors. Finite volume methods As usual, we integrate over a control volume \\(\\Omega\\). However, we note that only the normal component of flux will act to exchange mass across an edge. We also note that we will replace the flux \\(\\vec{f}\\) with the numerical flux \\(\\vec{f}^*(\\vec{u}_1, \\vec{u}_2)\\), which depends on the state vector on both sides of the boundary. Therefore, we end up with $$\\frac{\\partial \\vec{u}_i}{\\partial t} + \\frac{1}{|\\Omega_i|} \\sum_j \\vec{f}^*(\\vec{u}_i, \\vec{u}_j)l_j = 0$$ where \\(\\vec{u}_i\\) is the average of \\(\\vec{u}\\) on element \\(\\Omega_i\\), \\(|\\Omega_i|\\) is the area of the element, and \\(l_j\\) is the length of edge \\(\\Gamma_j\\). Numerical flux function We use a simple first-order numerical flux function, where we take the average of values on neighbouring elements. We add the minimum diffusion required for stability. This turns out to be $$\\vec{f}^*(\\vec{u}_1, \\vec{u}_2) = \\frac{1}{2}[\\vec{f}(\\vec{u}_1) + \\vec{f}(\\vec{u}_2)] - \\frac{\\alpha}{2}(\\vec{u}_2 - \\vec{u}_1)$$ where \\(\\alpha = \\frac{|m_n|}{h} + \\sqrt{h}\\) (which can be calculated from the eigenvalues of the flux Jacobian). Boundary conditions We apply ideal wall boundary conditions. That is, we implement ghost cells where we reverse the momentum components $$\\vec{u}_j = \\begin{bmatrix} h \\\\ -m_{n,i} \\\\ -m_{\\tau,i} \\end{bmatrix}$$ This ensures no mass crosses the boundary.","title":"Shallow water equations"},{"location":"shallow_water/#shallow-water-equations","text":"Our finite volume methods were originally developed for the shallow water equations. In a few senses this was an odd choice: Our eventual model has a scalar state variable. Our model is diffusive, so we do not need to add numerical diffusion. Nevertheless, they are a good test for our methods and provide a good case study.","title":"Shallow water equations"},{"location":"shallow_water/#two-dimensional-shallow-water-equations","text":"The shallow water solver solves the two-dimensional system of equations $$\\frac{\\partial}{\\partial t} \\begin{bmatrix} h \\\\ hu \\\\ hv \\end{bmatrix} + \\frac{\\partial}{\\partial x} \\begin{bmatrix} hu \\\\ hu^2 + \\frac{1}{2}gh^2 \\\\ huv \\end{bmatrix} + \\frac{\\partial}{\\partial y} \\begin{bmatrix} hv \\\\ huv \\\\ hv^2 + \\frac{1}{2}gh^2 \\end{bmatrix} = 0$$ We note that the conserved quantities in these equations are not the physical variables \\((h, u, v)\\), but are the depth and momenta \\(\\vec{u} = (h, m_x, m_y)\\), where \\(m-x = hu\\) and \\(m_y = hv\\). In terms of these conserved quantities, the equations become $$\\frac{\\partial}{\\partial t} \\begin{bmatrix} h \\\\ m_x \\\\ m_y \\end{bmatrix} + \\frac{\\partial}{\\partial x} \\begin{bmatrix} m_x \\\\ \\frac{m_x^2}{h} + \\frac{1}{2}gh^2 \\\\ \\frac{m_x m_y}{h} \\end{bmatrix} + \\frac{\\partial}{\\partial y} \\begin{bmatrix} m_y \\\\ \\frac{m_x m_y}{h} \\\\ \\frac{m_y^2}{h} + \\frac{1}{2}gh^2 \\end{bmatrix} = 0$$ We also note the symmetry between \\(x\\) and \\(y\\). We recognize the \\(\\frac{\\partial}{\\partial x}\\) term as representing the flux in the \\(x\\)-direction, and the \\(\\frac{\\partial}{\\partial y}\\) term as representing the flux in the \\(y\\)-direction (for example by integrating over a square). To apply finite volume methods, we therefore need to write the flux generally for normal and tangent momentum components. Let \\(m_n\\) by the normal component of momentum, and \\(m_\\tau\\) be the tangent component with respect to a a cell boundary. Then, we have that the flux is $$ \\vec{f}(\\vec{u}) = \\begin{bmatrix} f_h \\\\ f_n \\\\ f_\\tau \\end{bmatrix} = \\begin{bmatrix} m_n \\\\ \\frac{m_x^n}{h} + \\frac{1}{2}gh^2 \\\\ \\frac{m_n m_\\tau}{h} \\end{bmatrix}$$ Note that the first component says that convergence of the normal component of momentum causes an increase in water depth. This is exactly what we want! Now, we can write the system of equations as $$\\frac{\\partial \\vec{u}}{\\partial t} + \\frac{\\partial}{\\partial n} \\vec{f}(\\vec{u}) + \\frac{\\partial}{\\partial \\tau} \\vec{f}(\\vec{u}) = 0$$ where $\\vec{n} and \\vec{\\tau}$ are the normal and tangent vectors.","title":"Two-dimensional shallow water equations"},{"location":"shallow_water/#finite-volume-methods","text":"As usual, we integrate over a control volume \\(\\Omega\\). However, we note that only the normal component of flux will act to exchange mass across an edge. We also note that we will replace the flux \\(\\vec{f}\\) with the numerical flux \\(\\vec{f}^*(\\vec{u}_1, \\vec{u}_2)\\), which depends on the state vector on both sides of the boundary. Therefore, we end up with $$\\frac{\\partial \\vec{u}_i}{\\partial t} + \\frac{1}{|\\Omega_i|} \\sum_j \\vec{f}^*(\\vec{u}_i, \\vec{u}_j)l_j = 0$$ where \\(\\vec{u}_i\\) is the average of \\(\\vec{u}\\) on element \\(\\Omega_i\\), \\(|\\Omega_i|\\) is the area of the element, and \\(l_j\\) is the length of edge \\(\\Gamma_j\\).","title":"Finite volume methods"},{"location":"shallow_water/#numerical-flux-function","text":"We use a simple first-order numerical flux function, where we take the average of values on neighbouring elements. We add the minimum diffusion required for stability. This turns out to be $$\\vec{f}^*(\\vec{u}_1, \\vec{u}_2) = \\frac{1}{2}[\\vec{f}(\\vec{u}_1) + \\vec{f}(\\vec{u}_2)] - \\frac{\\alpha}{2}(\\vec{u}_2 - \\vec{u}_1)$$ where \\(\\alpha = \\frac{|m_n|}{h} + \\sqrt{h}\\) (which can be calculated from the eigenvalues of the flux Jacobian).","title":"Numerical flux function"},{"location":"shallow_water/#boundary-conditions","text":"We apply ideal wall boundary conditions. That is, we implement ghost cells where we reverse the momentum components $$\\vec{u}_j = \\begin{bmatrix} h \\\\ -m_{n,i} \\\\ -m_{\\tau,i} \\end{bmatrix}$$ This ensures no mass crosses the boundary.","title":"Boundary conditions"}]}